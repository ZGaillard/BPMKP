# Branch-and-Price MKP – report scratchpad

## Implementation snapshot
- Core model and IO live in `src/main/java/ca/udem/gaillarz/model` and `.../io`; instances are plain text under `src/main/resources/`.
- Formulations: classic MKP plus the L2 relaxation (eqs. 13–18) in `formulation/`. `DantzigWolfeMaster` encodes (28–33) with pattern pools `P0` (aggregate capacity) and `Pi` (per bin) seeded by `PatternGenerator`/`PatternInitializer`.
- Column generation: `solver/cg/ColumnGeneration` builds the restricted master (`DWMasterLPBuilder`), uses OR-Tools LP (`ORToolsSolver`), extracts duals, solves pricing as knapsacks (`PricingProblem`) and injects positive reduced-cost patterns. Basic duplicate/branch-compatibility filtering; no stabilization.
- Branch-and-price driver: `solver/bp/BranchAndPrice` runs best-first on node upper bounds, branches on fractional `t_j` only, reruns CG per node, and tries a CP-SAT feasibility repair (`solver/vsbpp/OrToolsCpSatVSBPPSATChecker`) when `t` is integral but assignments `x` are fractional. Infeasible selections trigger simple no-good cuts managed by `NoGoodCutManager`.
- Benchmarks/CLI: `Main` for interactive solving; `benchmark/MainBenchmark` for batch runs with configurable gap/time/node limits (`BenchmarkConfig`). Results CSV/JSON land under `benchmark_results/`, with plots in `analysis_out/` generated by `benchmark_analysis.ipynb`.

## Differences vs. Lalonde et al. (2022)
- No instance reduction or MULKNAP warm-start: the paper trims bins/items (Sec. 3.8) and runs MULKNAP for an initial LB/UB; the code jumps directly into pattern seeding + CG with no presolve or incumbent tightening.
- Upper-bound handling: the paper enforces `floor(UB)` in (31) tied to the current best solution; here `DantzigWolfeMaster` keeps a static UB = total profit and never updates it with incumbents, so the integrality encouragement is mostly inactive.
- Column generation extras: missing dual bound check (eq. 44), missing subgradient-based column generation when CG stalls (Sec. 3.4), and no stabilization. Pricing also ignores duals from no-good cuts (`θ_j`) and uses the simpler reduced costs without the `E(S)` strengthening of cuts (eq. 35).
- Branching/filtering: branching rule is “most fractional `t_j`” only; the paper uses the restricted candidate set with thresholds/largest impact rule (Sec. 3.6) plus item dominance and Lagrangian probing filters (Sec. 3.7) to fix more variables—none of these are in the code.
- Packing subproblem: paper’s VSBPP-SAT solver is multi-stage (heuristic → set packing → arc-flow/Reflect with free-space limits) and proves infeasibility; implementation uses a single CP-SAT feasibility attempt with a short timeout and treats UNKNOWN as “add a cut and retry.”
- Cuts: implementation adds plain no-good cuts over the exact selected set `S` only (eq. 34) and does not extend to `E(S)`; pricing is unaware of the cut duals. No specialized cover/strengthening beyond that.
- Tooling stack: code relies on OR-Tools (Java/GLOP) for LPs and CP-SAT; the paper uses CPLEX and bespoke routines, so performance bounds differ.

## Results on bundled runs
- `benchmark_results/time-limit600_gap0.01_max-nodes1000/SMALL_summary.json`: 179/179 solved, 105 proven optimal, 74 stopped at 1% gap; avg gap ≈ 0.001, avg time ≈ 12.7 s per instance (limits: 600 s, gap 1%, max nodes 10k).
- `benchmark_results/time-limit600_gap0_max-nodes1000/SMALL_summary.json`: rerun with gap tolerance 0, all 179 optimal but slower (avg ≈ 16.5 s).
- Subsampled FK_1 run (`..._max-instances10`) shows all 10 optimal with median times ~a few seconds (`FK_1_results.csv`).
- Plots/tables already in `analysis_out/` for direct inclusion (status/runtime distributions, by-set breakdowns).

## Experimental considerations
- Defaults: Java 25 + Maven; CG/BP defaults to gap 1%, 600 s/instance, max 10k nodes. OR-Tools native libs must load; otherwise CP-SAT/LP fall back poorly.
- Instance sets are pre-bundled (SMALL, FK_1–FK_4); CLI runner supports filtering/skipping sets and per-run gap/time tuning.
- No deterministic seeding beyond a fixed shuffle seed in `PatternGenerator`; OR-Tools randomness may introduce minor run-to-run variability.

## Draft LaTeX outline / next steps
- Intro: recap MKP + Lalonde et al. contribution (L2 dominance, DW+BAP with aggregated pool and VSBPP-SAT).
- Method (our code): formulations (classic, L2, DW), column generation loop, branching, CP-SAT repair, no-good cuts, pattern seeding.
- Comparison to paper: enumerate missing heuristics/cuts/filtering, solver/parameter differences, expected impact on bounds/runtime.
- Experiments: datasets, config (gap/time/nodes), hardware assumptions, headline metrics from the provided CSV/plots; note gaps vs. paper benchmarks.
- Future work: add dynamic UB tightening, `θ_j` pricing, subgradient stab, stronger VSBPP-SAT, and dominance/probing filters.
